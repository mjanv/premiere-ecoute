<!-- AIDEV-NOTE: Large overlay layout (1400x800px) featuring album cover, details, track list, progression bar, and voting scores -->
<div
  :if={@score in [:large]}
  id="overlay-container"
  style="
    --bg-primary: 0, 0, 0;
    --bg-secondary: 50, 50, 50;
    --accent-primary: 147, 51, 234;
    --accent-secondary: 79, 70, 229;
    background: linear-gradient(135deg, rgba(var(--bg-primary), 0.9) 0%, rgba(var(--bg-secondary), 0.85) 100%);
    display: flex; 
    flex-direction: column; 
    align-items: stretch; 
    gap: 20px; 
    padding: 20px; 
    width: 1300px; 
    height: 1000px; 
    box-sizing: border-box; 
    transition: background 0.5s ease;
  "
>
  <!-- Top Row: Album Cover with Details Below, and Track List -->
  <div style="display: flex; flex-direction: row; align-items: stretch; gap: 20px;">
    
<!-- Left Column: Album Cover and Details -->
    <div style="display: flex; flex-direction: column; gap: 20px; flex: 0 0 360px;">
      <!-- Album Cover -->
      <div style="width: 360px; height: 360px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); overflow: hidden;">
        <img
          id="album-cover"
          src={@listening_session.album.cover_url}
          alt={"#{@listening_session.album.name} cover"}
          style="width: 100%; height: 100%; object-fit: cover;"
          crossorigin="anonymous"
          onload="extractColorsAndApply(this)"
        />
      </div>
      
<!-- Album Details -->
      <%= if @listening_session.album do %>
        <div style="padding: 12px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);">
          <!-- Album Name -->
          <div style="font-size: 24px; font-weight: 600; color: white; margin-bottom: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
            {@listening_session.album.name}
          </div>
          
<!-- Artist -->
          <div style="font-size: 18px; font-weight: 500; color: rgba(255, 255, 255, 0.8); margin-bottom: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
            {@listening_session.album.artist}
          </div>
          
<!-- Release Date and Track Count -->
          <div style="font-size: 16px; color: rgba(255, 255, 255, 0.6);">
            {PremiereEcouteCore.Date.date(@listening_session.album.release_date)} â€¢ {@listening_session.album.total_tracks} tracks
          </div>
        </div>
        
<!-- Small footer under album details -->
        <div style="padding: 12px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); text-align: center;">
          <div style="font-size: 12px; color: rgba(255, 255, 255, 0.4); font-weight: 400;">
            Made with premiere-ecoute.fr
          </div>
        </div>
      <% else %>
        <div style="flex: 1; padding: 16px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);">
          <div style="color: rgba(255, 255, 255, 0.6);">No album information available</div>
        </div>
        
<!-- Small footer under album details -->
        <div style="padding: 12px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); text-align: center;">
          <div style="font-size: 12px; color: rgba(255, 255, 255, 0.4); font-weight: 400;">
            Made with premiere-ecoute.fr
          </div>
        </div>
      <% end %>
    </div>
    
<!-- Track Progression and List Column -->
    <div style="flex: 1; display: flex; flex-direction: column; gap: 20px;">
      
<!-- Voting Notes Row (above track progression) -->
      <div style="display: flex; flex-direction: row; align-items: stretch; gap: 20px; height: 150px;">
        
<!-- Viewer Note -->
        <.async_result :let={summary} assign={@summary}>
          <:loading>
            <div style="flex: 1; padding: 20px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 16px;">
              <div style="font-size: 80px; font-weight: 700; color: white; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);">-</div>
              <div style="font-size: 20px; color: rgba(255, 255, 255, 0.8); text-transform: capitalize; letter-spacing: 0.5px; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);">
                {score_label(:viewer)}
              </div>
            </div>
          </:loading>

          <div style="flex: 1; padding: 20px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 16px;">
            <div style="font-size: 80px; font-weight: 700; color: white; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);">
              <%= if @open_vote do %>
                {score_value(summary, :viewer)}
              <% else %>
                -
              <% end %>
            </div>
            <div style="font-size: 20px; color: rgba(255, 255, 255, 0.8); text-transform: capitalize; letter-spacing: 0.5px; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);">
              {score_label(:viewer)}
            </div>
          </div>
        </.async_result>
        
<!-- Streamer Note -->
        <.async_result :let={summary} assign={@summary}>
          <:loading>
            <div style="flex: 1; padding: 20px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 16px;">
              <div style="font-size: 80px; font-weight: 700; color: white; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);">-</div>
              <div style="font-size: 20px; color: rgba(255, 255, 255, 0.8); text-transform: capitalize; letter-spacing: 0.5px; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);">
                {score_label(:streamer)}
              </div>
            </div>
          </:loading>

          <div style="flex: 1; padding: 20px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: row; align-items: center; justify-content: center; gap: 16px;">
            <div style="font-size: 80px; font-weight: 700; color: white; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);">
              <%= if @open_vote do %>
                {score_value(summary, :streamer)}
              <% else %>
                -
              <% end %>
            </div>
            <div style="font-size: 20px; color: rgba(255, 255, 255, 0.8); text-transform: capitalize; letter-spacing: 0.5px; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);">
              {score_label(:streamer)}
            </div>
          </div>
        </.async_result>
      </div>
      
<!-- Track Progression Bar -->
      <div style="padding: 20px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);">
        
<!-- Progress bar and timer row -->
        <div style="display: flex; align-items: center; gap: 16px;">
          <!-- Progress bar container -->
          <div
            id="progress-bar-bg"
            style="flex: 1; height: 40px; border-radius: 8px; background-color: rgba(var(--bg-secondary), 0.3); overflow: hidden; transition: background-color 0.5s ease;"
          >
            <.async_result :let={progress} assign={@progress}>
              <:loading>
                <div
                  class="progress-bar-fill"
                  style="width: 0%; height: 100%; background: linear-gradient(to right, rgba(var(--accent-primary), 0.9) 0%, rgba(var(--accent-secondary), 0.7) 100%); transition: width 0.3s ease, background 0.5s ease;"
                >
                </div>
              </:loading>
              <:failed :let={_reason}>
                <div
                  class="progress-bar-fill"
                  style="width: 0%; height: 100%; background: linear-gradient(to right, rgba(var(--accent-primary), 0.9) 0%, rgba(var(--accent-secondary), 0.7) 100%); transition: width 0.3s ease, background 0.5s ease;"
                >
                </div>
              </:failed>

              <div
                class="progress-bar-fill"
                style={"width: #{round(100 * progress["progress_ms"] / progress["item"]["duration_ms"])}%; height: 100%; background: linear-gradient(to right, rgba(var(--accent-primary), 0.9) 0%, rgba(var(--accent-secondary), 0.7) 100%); transition: width 0.3s ease, background 0.5s ease;"}
              >
              </div>
            </.async_result>
          </div>
          
<!-- Time display on the right -->
          <div style="white-space: nowrap;">
            <.async_result :let={progress} assign={@progress}>
              <:loading>
                <span style="font-size: 18px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">
                  {PremiereEcouteCore.Duration.timer(0)} / {PremiereEcouteCore.Duration.timer(0)}
                </span>
              </:loading>

              <:failed :let={_reason}>
                <span style="font-size: 18px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">
                  {PremiereEcouteCore.Duration.timer(0)} / {PremiereEcouteCore.Duration.timer(0)}
                </span>
              </:failed>

              <span style="font-size: 18px; color: rgba(255, 255, 255, 0.9); font-weight: 600;">
                {PremiereEcouteCore.Duration.timer(progress["progress_ms"])} / {PremiereEcouteCore.Duration.timer(
                  progress["item"]["duration_ms"]
                )}
              </span>
            </.async_result>
          </div>
        </div>
      </div>
      
<!-- Track List -->
      <div style="flex: 1; min-height: 0; padding: 16px; border-radius: 12px; background-color: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: column;">
        <div style="flex: 1; overflow-y: auto; scrollbar-width: thin; scrollbar-color: rgba(255, 255, 255, 0.3) rgba(255, 255, 255, 0.1);">
          <%= for track <- Enum.sort_by(PremiereEcoute.Sessions.ListeningSession.tracks(@listening_session), & &1.track_number) do %>
            <% is_current_track =
              case @progress do
                %{ok?: true, result: progress} -> track.track_number == progress["item"]["track_number"]
                _ -> false
              end %>
            <div style={
              if is_current_track,
                do:
                  "background-color: rgba(255, 255, 255, 0.1); border-radius: 6px; padding: 8px 12px; margin-bottom: 4px; border-left: 3px solid #ff6b9d; display: flex; justify-content: space-between; align-items: center;",
                else:
                  "padding: 8px 12px; margin-bottom: 4px; display: flex; justify-content: space-between; align-items: center; border-radius: 6px; transition: background-color 0.2s ease;"
            }>
              <div style="font-size: 14px; font-weight: 600; color: white; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; margin-right: 12px;">
                {track.track_number}. {track.name}
              </div>
              <div style="font-size: 12px; color: rgba(255, 255, 255, 0.7); white-space: nowrap; font-weight: 500;">
                {PremiereEcouteCore.Duration.timer(track.duration_ms)}
              </div>
            </div>
          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  function extractColorsAndApply(img) {
    // Create a canvas to analyze the image
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size for performance (smaller = faster)
    const size = 100;
    canvas.width = size;
    canvas.height = size;
    
    // Draw the image to canvas
    ctx.drawImage(img, 0, 0, size, size);
    
    // Get image data
    const imageData = ctx.getImageData(0, 0, size, size);
    const data = imageData.data;
    
    // Extract colors by sampling every 4th pixel for performance
    const colors = [];
    for (let i = 0; i < data.length; i += 16) { // Skip pixels for performance
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      const a = data[i + 3];
      
      // Skip transparent or very dark/light pixels
      if (a > 200 && (r + g + b) > 50 && (r + g + b) < 700) {
        colors.push([r, g, b]);
      }
    }
    
    if (colors.length === 0) return;
    
    // Find dominant colors using k-means clustering (simplified)
    const dominantColors = getDominantColors(colors, 3);
    
    // Store colors in sessionStorage for persistence across LiveView updates
    sessionStorage.setItem('overlayColors', JSON.stringify(dominantColors));
    
    // Apply colors to UI
    applyColorsToUI(dominantColors);
  }

  // Reapply colors after LiveView updates
  function reapplyStoredColors() {
    const storedColors = sessionStorage.getItem('overlayColors');
    if (storedColors) {
      try {
        const colors = JSON.parse(storedColors);
        applyColorsToUI(colors);
      } catch (e) {
        console.warn('Failed to parse stored colors:', e);
      }
    }
  }

  // Listen for LiveView updates and reapply colors
  document.addEventListener('DOMContentLoaded', function() {
    // Reapply colors on initial load
    reapplyStoredColors();
    
    // Watch for LiveView updates using MutationObserver
    const observer = new MutationObserver(function(mutations) {
      mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' || mutation.type === 'attributes') {
          // Small delay to ensure DOM is updated
          setTimeout(reapplyStoredColors, 50);
        }
      });
    });
    
    // Observe changes to the overlay container
    const container = document.getElementById('overlay-container');
    if (container) {
      observer.observe(container, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style']
      });
    }
  });

  function getDominantColors(colors, k) {
    if (colors.length < k) return colors;
    
    // Simple k-means clustering
    let centroids = [];
    for (let i = 0; i < k; i++) {
      centroids.push(colors[Math.floor(i * colors.length / k)]);
    }
    
    // Iterate a few times to refine centroids
    for (let iteration = 0; iteration < 5; iteration++) {
      const clusters = Array(k).fill().map(() => []);
      
      // Assign colors to nearest centroid
      colors.forEach(color => {
        let minDist = Infinity;
        let clusterIndex = 0;
        
        centroids.forEach((centroid, i) => {
          const dist = Math.sqrt(
            Math.pow(color[0] - centroid[0], 2) +
            Math.pow(color[1] - centroid[1], 2) +
            Math.pow(color[2] - centroid[2], 2)
          );
          if (dist < minDist) {
            minDist = dist;
            clusterIndex = i;
          }
        });
        
        clusters[clusterIndex].push(color);
      });
      
      // Update centroids
      centroids = clusters.map(cluster => {
        if (cluster.length === 0) return centroids[0];
        const r = cluster.reduce((sum, c) => sum + c[0], 0) / cluster.length;
        const g = cluster.reduce((sum, c) => sum + c[1], 0) / cluster.length;
        const b = cluster.reduce((sum, c) => sum + c[2], 0) / cluster.length;
        return [Math.round(r), Math.round(g), Math.round(b)];
      });
    }
    
    return centroids;
  }

  function applyColorsToUI(colors) {
    if (colors.length === 0) return;
    
    // Sort colors by brightness to get darkest and brightest
    const sortedColors = colors.sort((a, b) => {
      const brightnessA = (a[0] * 299 + a[1] * 587 + a[2] * 114) / 1000;
      const brightnessB = (b[0] * 299 + b[1] * 587 + b[2] * 114) / 1000;
      return brightnessA - brightnessB;
    });
    
    const darkest = sortedColors[0];
    const brightest = sortedColors[sortedColors.length - 1];
    const middle = sortedColors[Math.floor(sortedColors.length / 2)];
    
    // Ensure colors work with white text (darken if too bright)
    const backgroundPrimary = ensureContrast(darkest, 0.8);
    const backgroundSecondary = ensureContrast(middle, 0.6);
    const accentPrimary = ensureContrast(brightest, 0.9);
    const accentSecondary = ensureContrast(middle, 0.8);
    
    // Update CSS custom properties on the container
    const container = document.getElementById('overlay-container');
    if (container) {
      container.style.setProperty('--bg-primary', `${backgroundPrimary[0]}, ${backgroundPrimary[1]}, ${backgroundPrimary[2]}`);
      container.style.setProperty('--bg-secondary', `${backgroundSecondary[0]}, ${backgroundSecondary[1]}, ${backgroundSecondary[2]}`);
      container.style.setProperty('--accent-primary', `${accentPrimary[0]}, ${accentPrimary[1]}, ${accentPrimary[2]}`);
      container.style.setProperty('--accent-secondary', `${accentSecondary[0]}, ${accentSecondary[1]}, ${accentSecondary[2]}`);
    }
  }

  function ensureContrast(color, darkenFactor) {
    // Calculate relative luminance
    const [r, g, b] = color.map(c => {
      c = c / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    
    // If too bright (low contrast with white), darken it
    if (luminance > 0.5) {
      return color.map(c => Math.round(c * darkenFactor));
    }
    
    return color;
  }
</script>
